[{"data":1,"prerenderedAt":41},["ShallowReactive",2],{"search-api":3},[4,11,21,30],{"id":5,"path":6,"dir":7,"title":8,"description":7,"keywords":9,"body":10},"content:0.index.md","/","","Home",[],"     Easy solution to store files in your nuxt apps.   Be able to upload files from the frontend and recieve them from the backend to then save the files in your project.     Get files from   file input  and make them ready to send to backend  Serialize files in the backend to be able to use them appropriately  Store files in a specified location in your Nuxt backend with Nitro Engine       Independent Storage   Use your Nuxt app to independently store all the files you need from your users.    Handle File Inputs   You can use this module to cleanly handle file inputs.    Serialize Files in Backend   Get all the data you need from the files submitted even if you don't want to store them in your backend.   What's included  ",{"id":12,"path":13,"dir":14,"title":15,"description":16,"keywords":17,"body":20},"content:1.introduction:1.getting-started.md","/introduction/getting-started","introduction","Getting Started","Here is a simple guide to setting up Nuxt File Storage in your project.",[18,19],"Play online","Add to your project","  Getting Started  Here is a simple guide to setting up   Nuxt File Storage  in your project.  Play online  You can play with Nuxt File Storage in your browser using Stackblitz:  Play on StackBlitz  Add to your project   Go to your project and type in:     npx   nuxi@latest   module   add   nuxt-file-storage\n   add   nuxt-file-storage  to your modules:     export   default   defineNuxtConfig  ({\n       modules: [  'nuxt-file-storage'  ],\n   })\n   add the absolute   mount  location:      export   default   defineNuxtConfig  ({\n       modules: [  'nuxt-file-storage'  ],\n       fileStorage: {\n           mount: process.env.mount\n       },\n   })\n     mount  =  '/home/$USR/development/your-nuxt-app/server/files'\n   You should definitely use Environment Variables   .env  instead of hard-coding your mount to differentiate between local development and deployment and to not expose your file system structure to your project.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":22,"path":23,"dir":14,"title":24,"description":25,"keywords":26,"body":29},"content:1.introduction:2.frontend-usage.md","/introduction/frontend-usage","Frontend Usage","there are two ways to handle input and they are based on your usage with the files.",[27,28],"Multipart Data Object","Base64 for JSON","  Frontend Usage  there are two ways to handle input and they are based on your usage with the files.  Multipart Data Object  This method is the most optimal specifically for file uploading alone:     \u003C  template  >\n       \u003C  input   type  =  \"file\"   @  input  =  \"  handleFileInput  \"   />\n   \u003C/  template  >\n   \n   \u003C  script   setup  >\n       const   {   handleFileInput  ,   files   }   =   useFileStorage  ()\n   \u003C/  script  >\n    handleFileInput  handles multiple files by default   files  will return a   formData  object that will be ready for upload  then you upload the files like this:     const   response   =   await   $fetch  (  '/api/files'  , {\n       method:   'POST'  ,\n       body: files\n     })\n  for handling the backend side of the files check the   Multipart Object Method .  Base64 for JSON  This method is more optimal if you want to upload the files with more JSON data:     \u003C  template  >\n       \u003C  input   type  =  \"file\"   @  input  =  \"  handleJsonFileInput  \"   />\n   \u003C/  template  >\n   \n   \u003C  script   setup  >\n       const   {   handleJsonFileInput  ,   jsonFiles   }   =   useFileStorage  ()\n   \u003C/  script  >\n   jsonFiles  will return a vue   ref  list that has the files  This will allow you to upload the files in JSON form with other JSON data:     const   response   =   await   $fetch  (  '/api/file'  , {\n     method:   'POST'  ,\n     body: {\n       // other data\n       files: jsonFiles.value\n     }\n   })\n   this method is not the most recommended but is still applicable if needed  For handling the backend side of the files check the   Base64 for JSON Method .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":31,"path":32,"dir":14,"title":33,"description":34,"keywords":35,"body":40},"content:1.introduction:3.backend-usage.md","/introduction/backend-usage","Backend Usage","using Nitro Server Engine, we will make an api route that recieves the files and stores them in the folder userFiles",[36,37,38,39],"Multipart Object Method","JSON Method","Updating Files","Deleting Files","  Backend Usage  using Nitro Server Engine, we will make an api route that recieves the files and stores them in the folder   userFiles  since we have two methods of uploading from the frontend there will be also two methods of handling the request from the backend   Beware of writing the same file name to the same location,   here is why .  Multipart Object Method  open a new api route:   /server/api/file.ts      export   default   defineEventHandler  (  async   (  event  )   =>   {\n       const   files   =   (  await   readMultipartFormData  (event))   ||   []\n   \n       const   fileName   =   await   storeFile  (\n           files[  0  ],      // the file object\n           12  ,            // you can add a name for the file or length of Unique ID that will be automatically generated!\n           '/userFiles'   // the folder the file will be stored in\n       )\n   \n       return   fileName\n   })\n     export   default   defineEventHandler  (  async   (  event  )   =>   {\n       const   files   =   (  await   readMultipartFormData  (event))   ||   []\n       const   fileNames  :   string  []   =   []\n   \n       for   (  const   file   of   files) {\n           fileNames.  push  (\n               await   storeFile  (\n                   file,          // the file object\n                   'fileName'  ,    // you can add a name for the file or length of Unique ID that will be automatically generated!\n                   '/userFiles'   // the folder the file will be stored in\n               )\n           )\n       }\n   \n       return   fileNames\n   })\n     storeFile  will return the name of the file that was stored    Storing with the random title generator will return the name of the file  Example code:\n  await storeFile(file, 8, '/userFiles')  Example of what it will return:   \"f09Riodv.png\"   Storing with a custom name will return the file name including the extension:   fileName.png  JSON Method      export   default   defineEventHandler  (  async   (  event  )   =>   {\n       const   {   files   }   =   await   readBody  \u003C{   files  :   File  [] }>(event)\n   \n       const   fileName   =   await   storeFileJson  (\n           files[  0  ],       // the file object\n           8  ,              // you can add a name for the file or length of Unique ID that will be automatically generated!\n           '/userFiles'    // the folder the file will be stored in\n       )\n   \n       return   fileName\n   })\n   \n   interface   File   {\n       name  :   string\n       size  :   number\n       type  :   string\n       lastModified  :   date  ,\n       content  :   string  ,\n   }\n     export   default   defineEventHandler  (  async   (  event  )   =>   {\n     const   {   files   }   =   await   readBody  \u003C{   files  :   File  [] }>(event)\n       const   fileNames  :   string  []   =   []\n   \n       for   (  const   file   of   files) {\n           fileNames.  push  (  await   storeFileJson  (\n               file,           // the file object\n               8  ,              // you can add a name for the file or length of Unique ID that will be automatically generated!\n               '/userFiles'    // the folder the file will be stored in\n           ))\n     }\n   \n       return   fileNames\n   })\n   \n   interface   File   {\n       name  :   string\n       size  :   number\n       type  :   string\n       lastModified  :   date  ,\n       content  :   string  ,\n   }\n  Get File Data  If you need to get the data of the file without storing it you can use the   parseDataUrl  Method     const   {   binaryString  ,   ext   }   =   parseDataUrl  (file.content)\n   This function only works for Base64 files \"the JSON method\"  Updating Files  If you want to update a file you just have to store a new file with the   same name  and it will automatically write the new file content to the same file title.  Deleting Files  Get the name and location of the file you want to delete and run it through this command through your api handler     await   deleteFile  (\n     \"fileName.png\"  ,\n     \"/specificFolder\"\n   )\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",1719078113591]